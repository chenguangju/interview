Hashmap实现原理及扩容机制详解
https://blog.csdn.net/lkforce/article/details/89521318?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-89521318-blog-123798887.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-89521318-blog-123798887.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2
1、核心参数
默认初始容量 16

最大容量 2^30

默认加载因子 0.75
乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容；为什么设置 0.75 这个值呢，简单来说就是时间和空间的权衡。
若小于0.75如0.5，则数组长度达到一半大小就需要扩容，空间使用率大大降低，若大于0.75如0.8，则会增大hash冲突的概率，影响查询效率。

链表转红黑树阈值 8
当链表长度大于等于8，并且数组容量大于64才会转化为红黑树，容量小于64会先扩容

红黑树退化链表阈值 6
红黑树的节点个数到6个时退化为链表

最小转换红黑树的数组容量 64

int threshold;扩容阈值

final float loadFactor; 加载因子

int size;map中k-v对总数量

2、 put过程
a)根据key获取hash值
b)判断数组是否初始化过，如果没有则进行扩容操作，数组容量为2的n次幂
c)根据hash值和数组长度计算下标，如果数组下标位置正好没有数据则直接构造一个节点放入数组
d)如果该位置有元素的话就判断put进来的key和生成的hash值与当前数组Node节点的key和hash值是否相同，如果相同的话就把就进行值的替换
e)如果下标有值并且和传进来的key和hash值不通，则判断当前是树节点还是链表
f)如果是红黑树，遍历树,key和hash相同就替换值，不相同就插入
g)如果是链表的话，就遍历该链表,key和hash相同就替换值，不相同就插入
h)如果链表中插入节点的时候，如果链表长度大于等于8且数组容量小于64则进行扩容；
如果链表长度大于等于8且数组容量大于64则进行链表转换为红黑树；
i)最后所有元素处理完成后，判断是否超过阈值；threshold，超过则扩容。

3、 get过程
a)根据key获取hash值
b)如果数组没有初始化过，或者根据hash值和数组长度计算下标里没有值，则返回空
c)根据hash值和数组长度计算下标里有值,判断是不是和当前的key和hash相同，相同则返回数组里的值，也就头结点
d)如果和头结点不相等，则判断是不是树，是树则从树上查询返回，是链表则遍历链表取相等的返回


4、 默认构造参数和有参构造函数？
在创建hashmap对象时并不初始化数组容量，在put时进行扩容初始化。
当为默认构造时，设置loadFactor为默认加载因子，首次put进行一次扩容，初始容量为16，扩容阈值threshold=16*0.75=12
有参构造函数时（设置初始容量构造函数），设置loadFactor为默认加载因子，设置threshold为设置的设置容量的下一个是2^n数值，
然后首次put进行一次扩容，设置初始容量为threshold，并重新计算threshold=2^n*0.75

5、创建hashmap时设置初始容量为10，当put第100个元素时扩容了几次
在进行初始化时进行一次扩容，实际初始容量为16，能放下100个元素，容量最少是128，从16到128需要扩容3次算上首次为4次
128的扩容阈值是128*0.75即96，也就是说在put到96个元素的时候已经扩容了4次，容量到达128但是在put97个元素的时候再次扩容
到达256个容量。也即扩容5次

6、java 8散列函数为什么要hash和自己的右移16位异或？(h = key.hashCode()) ^ (h >>> 16);
这是一个扰动函数，用于优化散列效果，使得散列更随机，减少hash碰撞。结果使得低16位更加散列话，低16位也能存储10w+的数据
如果我们还沿用hashCode&(length-1),因为length-1为每位都是1，散列效果取决于hashCode和length-1的位数，我们一把用hashMap并不会存储
很多的数据所以，length-1并不会很大，所以这时hashCode的高16位完全没用，如果通过右移16位再异或，使得高16位参与散列。使得散列更好，更不容易发生
hash碰撞

7、为什么不使用hashcode作为数组下标？
虽然hashcode是一个int值但是其范围是[-2147483648, 2147483647]有近40亿长度，数组不能初始化如此长度，内存也放不下。必须使用数组长度取模来分散到数组
取模可以用%或者与运算，与运算需要是2的n次幂，与运算更高效。这也是数组长度是2的n次幂的一个原因

8、hashmap如果寻找2的倍数最小值的？
如果把一个十进制数表示为2进制，并且把除第一个有效位后面的各位表示为1，即二进制数都是1，则是一个标准的2的倍数减1，再加上1正好是2的倍数
那下面的代码减1是什么意思？为了解决当初始容量正好是2的倍数时，再填充1数值就变为下一个2的n+1次幂减1了。
一个int类型32位，如果最高位是1，经过第一个右移或则变为前两位是即11，在右移两位或则变为前4位是1，即1111.
以此类推变为1111 1111 -》 1111 1111 1111 1111 -》  1111 1111 1111 1111 1111 1111 1111 1111正好把所有位数都填满，正常来说不可能最高位是1
则只要做几次无用操作也是可以达到效果的
举两个例子：
如果cap是 16，cap-1=15 表示为 1111 无论右移多少最后n还是1111再加上1 则还是16，这就是减一的效果
如果cap是 11，cap-1=10 表示为 1010 右移1位为0101或1010结果为1111，加下来无论右移多少都是1111即十进制15，再加上1位16正好是2的4次方
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

9、hashmap 扩容过程
a)当hashmap的中的所有元素的数量超过扩容阈值，则进行扩容
b)扩容为原来数组长度的2倍
c)对map中的元素进行位置调整
如果数组索引中只有一个元素，直接按新数组大小计算数组索引
如果数组索引中是树，则拆分树，必要是退化为链表
如果数组中是链表，则用hash&oldcap计算位置变没变，没变放入新数组相同位置上，变了放入新数组的老位置+oldcap上



10、为什么数组长度和扩容都是2的倍数
a)可以使散列更随机。当是2的倍数时length-1为 类似于1111这样，与操作只和hash函数有关和数组长度无关
b)效率高。要定位数组索引，需要根据数组长度去取模。而如果数组长度是2的幂，则取模和与运算等价，并且与运算效率更高
c)扩容效率高。在扩容时，不需要重新计算hash值。

11、java8 扩容为什么不需要重新计算hash值？
扩容是原来的2倍。计算数组索引（n-1）& hash
假如A数据经过hash得到的hash为10111，一开始map的数组长度为8,则根据定位逻辑（n-1）& hash
数据A的位置：(n-1)&hash = (8-1) & 10111 = 111 & 10111 = 111
扩容之后数组长度是原来的2倍，即16，假设我们重新算一遍A的位置，那么应该是：
(n-1)&hash = (16-1) & 10111 = 1111 & 10111 = 111
可以看到扩容前后的索引没有变
其实可以看到因为n-1的n是2的倍数n-1正好是，所有位都是1.扩容后只是比扩容前的高位增加了1，由111-》1111
最终的不同也是由这一位造成可（扩容前后的后几位不变），这一位可以是0或者1，是0表示位置不变，是1表示正好在原来的位置上增加了原来的数组长度，由111-》1111 =111+1000=111+8
则用与运算直接e.hash & oldCap（表示为10000..），单独把这一位提出来与运算，为0表示位置不变，为其他表示位置变了


12、1.7和1.8中hashMap的区别
1）优化了散列算法，1.8中使用hashCode和自己右移16位异或，散列效果更好，1.7中是直接用的hashCode
2）优化了查询效率，1.8中采用的底层数据结构是数组+链表+红黑树，1.7中使用的是数据+链表。当链表过长时红黑树的查询效率要优于链表
红黑树搜索时间复杂度是O(logn)，而链表是O(n)。空间换时间





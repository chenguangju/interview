Hashmap实现原理及扩容机制详解
https://blog.csdn.net/lkforce/article/details/89521318?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-89521318-blog-123798887.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-89521318-blog-123798887.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2
1、核心参数
默认初始容量 16

最大容量 2^30

默认加载因子 0.75
乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容；为什么设置 0.75 这个值呢，简单来说就是时间和空间的权衡。
若小于0.75如0.5，则数组长度达到一半大小就需要扩容，空间使用率大大降低，若大于0.75如0.8，则会增大hash冲突的概率，影响查询效率。

链表转红黑树阈值 8
当链表长度大于等于8，并且数组容量大于64才会转化为红黑树，容量小于64会先扩容

红黑树退化链表阈值 6
红黑树的节点个数到6个时退化为链表

最小转换红黑树的数组容量 64

int threshold;扩容阈值

final float loadFactor; 加载因子

int size;map中k-v对总数量

2、 put过程
a)根据key获取hash值
b)判断数组是否初始化过，如果没有则进行扩容操作，数组容量为2的n次幂
c)根据hash值和数组长度计算下标，如果数组下标位置正好没有数据则直接构造一个节点放入
d)如果该位置有元素的话就判断put进来的key和生成的hash值与当前数组Node节点的key和hash值是否相同，如果相同的话就把就进行值的替换
e)如果下标有值并且和传进来的key和hash值不通，则判断当前是树节点还是链表
f)如果是红黑树，遍历树,key和hash相同就替换值，不相同就插入
g)如果是链表的话，就遍历该链表,key和hash相同就替换值，不相同就插入
h)如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。
i)最后所有元素处理完成后，判断是否超过阈值；threshold，超过则扩容。

3、 get过程

4、 默认构造参数和有参构造函数？
在创建hashmap对象时并不初始化数组容量，在put时进行扩容初始化。
当为默认构造时，设置loadFactor为默认加载因子，首次put进行一次扩容，初始容量为16，扩容阈值threshold=16*0.75=12
有参构造函数时（设置初始容量构造函数），设置loadFactor为默认加载因子，设置threshold为设置的设置容量的下一个是2^n数值，
然后首次put进行一次扩容，设置初始容量为threshold，并重新计算threshold=2^n*0.75

5、创建hashmap时设置初始容量为10，当put第100个元素时扩容了几次，没有hash碰撞情况
在进行初始化时进行一次扩容，实际初始容量为16，能放下100个元素，容量最少是128，从16到128需要扩容3次算上首次为4次
128的扩容阈值是128*0.75即96，也就是说在put到96个元素的时候已经扩容了4次，容量到达128但是在put97个元素的时候再次扩容
到达256个容量。也即扩容5次

6、java 8散列函数为什么要hash和自己的右移16位异或？(h = key.hashCode()) ^ (h >>> 16);
这是一个扰动函数，用于优化散列效果，使得散列更随机，减少hash碰撞

7、为什么不使用hashcode作为数组下标？
虽然hashcode是一个int值但是其范围是[-2147483648, 2147483647]有近40亿长度，数组不能初始化如此长度，内存也放不下。必须使用数组长度取模来分散到数组
取模可以用%或者与运算，与运算需要是2的n次幂，与运算更高效。这也是数组长度是2的n次幂的一个原因

8、hashmap如果寻找2的倍数最小值的？
如果把一个十进制数表示为2进制，并且把除第一个有效位后面的各位表示为1，即二进制数都是1，则是一个标准的2的倍数减1，再加上1正好是2的倍数
那下面的代码减1是什么意思？为了解决当初始容量正好是2的倍数时，再填充1数值就变为下一个2的n+1次幂减1了。
一个int类型32位，如果最高位是1，经过第一个右移或则变为前两位是即11，在右移两位或则变为前4位是1，即1111.
以此类推变为1111 1111 -》 1111 1111 1111 1111 -》  1111 1111 1111 1111 1111 1111 1111 1111正好把所有位数都填满，正常来说不可能最高位是1
则只要做几次无用操作也是可以达到效果的
举两个例子：
如果cap是 16，cap-1=15 表示为 1111 无论右移多少最后n还是1111再加上1 则还是16，这就是减一的效果
如果cap是 11，cap-1=10 表示为 1010 右移1位为0101或1010结果为1111，加下来无论右移多少都是1111即十进制15，再加上1位16正好是2的4次方
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}


MappingRegistry 
（RequestMappingInfoHandlerMapping）启动阶段会遍历spring容器中的所有的bean,找到所有的controller(有@Controller或者@RequestMapping注解)，遍历controller中的所有的方法
把请求地址和请求方式封装成RequestMappingInfo(各种 RequestCondition集合，主要对应@RequestMapping注解参数，重要的是PatternsRequestCondition对应path
和RequestMethodsRequestCondition对应请求方式),把方法封装成HandlerMethod(包含反射的Method[可以反射拿到所有东西] 参数 bean等参数)。
最后把RequestMappingInfo与HandlerMethod做成映射放到MappingRegistry的mappingLookup(map)中RequestMappingInfo为key,HandlerMethod为value

当来了一个请求时，会在MappingRegistry的mappingLookup中查找HandlerMethod（根据请求地址）。再后根据请求地址和拦截器intercepter的匹配路径查找所用
应用的拦截器。封装成HandlerExecutionChain返回。

接下来就是基于handler,去获取HandlerAdapter，具体就是程序中内置了各种能处理handler(因为handler是Object对象，必须找到能具体执行handler的HandlerAdapter)
我们常用基于基于@RequestMapping，其中的handler为HandlerMethod类型，找到的HandlerAdapter是RequestMappingHandlerAdapter

然后执行HandlerExecutionChain中拦截器的所有的PreHandle方法，返回true时，才会通过RequestMappingHandlerAdapter执行方法


通过RequestMappingHandlerAdapter执行handler:
1、解析参数。根据参数类型获取能解析参数的解析器。程序内置了30多种参数解析器
比如RequestParamMethodArgumentResolver用于解析参数中标注@RequestParam,PathVariableMethodArgumentResolver用于解析参数中标注@PathVariable等
2、反射执行controller中的方法，返回ModelAndView
3、对返回的结果应用返回参数解析器，内置有15种
比如RequestResponseBodyMethodProcessor用于解析类中或方法中标注了@ResponseBody注解的返回值

然后执行拦截器的PostHandle方法

对于视图解析器，在当前大环境（spring boot，前后端分离）已经基本用不到了，后端只返回数据（注解有@ResponseBody）。
这时返回的ModelAndView都为空，表是不需要跳转页面。则视图解析器也没有作用


组件之一HandlerMapping,作用是根据当前的request对象，返回一个HandlerExecutionChain（HandlerExecutionChain getHandler(HttpServletRequest request)），
其中包含了处理器（handler）和拦截器数组（HandlerInterceptor）AbstractHandlerMapping是HandlerMapping的抽象类，
实现了HandlerExecutionChain getHandler(HttpServletRequest request)骨架，对子类开放getHandlerInternal方法。模板方法模式

AbstractHandlerMapping 的子类，分成两派：
基于 URL 进行匹配  AbstractUrlHandlerMapping系列， 如BeanNameUrlHandlerMapping，SimpleUrlHandlerMapping
基于 Method 进行匹配 AbstractHandlerMethodMapping系列，如RequestMappingHandlerMapping,RequestMappingInfoHandlerMapping
由于我们在开发中基本都是使用基于 Method 进行匹配所以只考虑AbstractHandlerMethodMapping系列（基于@RequestMapping）
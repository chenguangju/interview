jvm中的常量池分为三种
   1.类文件常量池(Class Constant Pool) 也称静态常量池
   2.运行时常量池(Runtime Constant Pool)
   3.字符串常量池(String Constant Pool）

1.类文件常量池
我们写的每一个Java类被编译后，就会形成一份class文件（每个class文件都有一个class常量池）。
class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，
用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。
字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;
符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。

2. 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。jdk1.8以前存在于永久代，jdk1.8之后存在于元空间。
静态常量池中的内容，在类加载后会被存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，
Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中静态常量池的内容才能进入方法区运行时常量池，
运行期间也可以将新的常量放入池中。

3.字符串常量池
字符串常量池存在运行时常量池之中（在JDK7之前存在运行时常量池之中，在JDK7已经将其转移到堆中）。
字符串常量池的存在使JVM提高了性能和减少了内存开销。


加载时，对于class文件的静态常量池，字符串字面量会进入到当前类的运行时常量池，但不会立即进入全局的字符串常量池
（即在字符串常量池中并没有相应的引用，在堆中也没有对应的对象产生），字符串常量池是lazy resolve的，
在第一次引用该项的ldc指令被第一次执行到的时候才会resolve，但这个过程我们可以不关注。可以认为当类加载完成后，
运行代码String str1="abc"或String str2=new String(“abc”)时，字面量“abc”已经存在于字符串常量池。jdk7字符串常量池以后存在于堆中。



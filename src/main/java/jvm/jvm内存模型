1、jvm内存模型
jvm定义了若干个java程序在运行时期用到的内存区域。
包括虚拟机栈、本地方法栈、程序计数器、方法区(元数据区)、堆内存
1.8把方法区改成元数据区，并移到了直接内存中。并且把字符串常量池移到了堆内存中
其中虚拟机栈、本地方法栈、程序计数器是线程私有的，每个线程一份
方法区和堆空间是线程共有的

2、各个区域的作用
程序计数器：记录着当前执行的字节码指令的位置
虚拟机栈：存储的一个一个的栈帧。每个方法在执行的时候，都会创建一个栈帧存放局部变量、方法名等信息
本地方法栈：和虚拟机栈类似，存储的native方法的局部变量等信息
堆内存：存储着我们在代码中存储的各种对象（1.8之后字符串常量池存放在着）
方法区：存放着.class类信息，包括类名、字段信息、方法信息；和常量池 （运行时常量池）

3、为什么废除方法区
由于方法区内存经常不够用或发生内存泄露，爆出异常 java.lang.OutOfMemoryError: PermGen

4、Java 内存堆和栈区别
JVM 中堆和栈属于不同的内存区域，使用目的也不同。
栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享

5、什么新生代、老年代
堆是垃圾回收的重点区域，分为新生代和老年代方便不同的垃圾回收算法执行，提高回收效率。
新生代主要存放新创建的对象和生命周期比较短的对象,新生代又分为1个E区和两个S区，比例8:1:1
老年代主要存放大对象和一直存活的对象

6、如何判断一个对象是否已经死去
引用计数：一个对象被引用一次，对象的引用计数加上1，释放引用计数减1，计数为0时可以回收；无法解决循环引用问题
可达性分析：从GC Roots开始向下搜索，路径称为引用链。如果一个对象到GC Root没有任何引用链时，则证明此对象已经死去，可以被回收
java中用的是可达性分析
7、可以当做GC Roots的对象
虚拟机栈中引用的对象作为GC Roots：
    对应方法中的局部变量，在方法执行期间可以作为GC ROOT，执行完后被回收
方法区中的静态变量引用的对象作为GC Roots
    对应类中的静态变量，在类存在期间可以作为GC ROOT
方法区中常量引用对象作为GC Roots
    对应类static final 对象

8、垃圾回收算法
标记-清除算法：标记和清除阶段；标记阶段：从CG ROOT开始标记可达对象，未被标记的为要回收的对象；清除阶段：清除未被标记的对象
标记-整理算法：标记和整理阶段；标记：从CG ROOT开始标记可达对象，未被标记的为要回收的对象；整理阶段：让所有被标记的对象向内存一侧移动；清除未被标记的对象
复制算法：内存分为两块区域，当一块用完把存活的对象移动的另一块。然后清理已经用过的内存块
分代收集算法：把内存区域划分为几块，java分为新生代和老年代；根据不同年代的特点用不同的算法
新生代：复制算法；老年代：标记整理或标记清除算法



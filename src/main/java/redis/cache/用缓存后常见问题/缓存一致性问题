我们一般用缓存时，缓存数据都是从数据库加载的，某些时候会造成数据不一致
原因
1、高并发下，读取到旧的DB数据到缓存，造成的。（先淘汰缓存，在更新数据库）
高并发下，A线程更新数据，先把缓存清空后去更新数据库，这时候还没有更新成功，B线程去请求数据，发现缓存为空，立马查询DB数据并更新到缓存
，之后A线程更新数据成功。造成缓存里的数据是旧的。
2、DB和缓存不在一个事务中，导致更新DB成功，更新缓存失败。造成数据不一致（先更新数据库在淘汰缓存）
解决
1、针对先淘汰缓存，在更新数据库，采用分布式锁。会造成不一致的原因是存在并行写，即B线程插入到A线程过程中。
并行写转为串行写。在写请求来的时候，淘汰缓存之前加上分布式锁。读请求来时发现缓存是空的，然后获取分布式锁，去查询重建缓存。
这样只有一个线程可以写到数据。
2、针对先更新数据库，在删除缓存，采用“同一事务”。
1）如果能用分布式事务最好。
2）删除缓存失败后。在同一个事务中，插入一条缓存信息，开启定时任务去更新缓存
3）基于数据库的 binlog 日志。
我们用的是：缓存双淘汰机制，在更新数据库前先淘汰缓存，然后对写入缓存的值设置超时时间
极端场景下即使有脏数据，过了超时时间也会自动销毁
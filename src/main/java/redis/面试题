1、redis 键过期策略
惰性删除：当访问一个key是才判断是否过期，过期了就删除。节省cpu 对内存不友好
定期删除：定期的在设置了过期键的key中，随机选择一部分，检查是否过期。过期则删除
2、redis 内存淘汰策略
当redis内存不足时，会触发内存淘汰策略，
3、reids hash数据类型的rehash过程,渐进式rehash?
    当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：
    1、服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；
    2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5（避免执行命令期间进行扩容；避免过多内存写入，造成性能低下。） ；

    当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。

    其中哈希表的负载因子可以通过公式计算：
    # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
    load_factor = ht[0].used / ht[0].size

    Redis 对字典的哈希表执行 rehash 的步骤：
    1、为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是ht[0].used 属性的值）：
    1.1、如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n；
    1.2、如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。
    2、将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：
    rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。
    3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ，
    将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。

    渐进式 rehash：
    扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面。
    但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。

    原因：
    如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ；
    但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对，
    那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。

    因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ，
    而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。

    以下是哈希表渐进式 rehash 的详细步骤：
    1、为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
    2、在字典中维持一个索引计数器变量 rehashidx(代表数组索引值) ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
    3、在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外，
    还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
    4、随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ，
    这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。

    渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。
    在rehash期间进行删除、查找、更新操作会在两个哈希表上进行；新增则只会在ht[1]进行，ht[0]不进行任何添加操作，这一操作保证ht[0]只减不增，最终编程空表


4、redis hash与java hashmap
    redis 数组+单项链表，为了速度采用头插法（单线程不存在链表循环）。
    hashmap 数组+单项链表+红黑树。为了解决头插法在并发下链表循环问题，采用尾插法。
    redis 扩容是渐进式的。hashmap的扩容是一次性的
    redis 可以收缩。hashmap不可以
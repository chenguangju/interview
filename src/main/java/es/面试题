1、深度分页问题是什么？怎么解决
es中的数据是分片存储的，所有的分片的总和是某个索引的全部数据。es中默认的分页查询参数是from+to,form表示从第几条数据开始取，to表示
取几条。es的分页查询是在每个分片上取前from+to条数据，然后全局排序，然后取全局排序的前每页条数条
比如我一个索引分了5片，我要取 page为1000 size为10的数据，则form参数为10000 to为10 也就是说每个数据分片上取前10010数据，一个50050
条然后做全局排序，取从10000到10010的数据返回，这样效率非常低，占用大量cpu

解决：
1、es中对from+to做了限制，其最大值为10000.不允许进行深度分页；可以修改max_result_window改变最大值
2、使用游标(滚屏):基于查询结果生成一个快照，我们可以翻页去查找我们需要的数据
局限性：数据实时性不高，滚屏期间有数据变化，也不会感知到；滚屏分页完毕后要及时清理，滚屏很消耗性能
3、使用search_after：在使用search_after需要传递sort排序字段，安排续字段排序查询结果，在匹配到的每页最后一条数据打上标记，
下次查询的时候，带上这个标记就能分页查询



修改max_result_window（很不推荐）、游标(滚屏)、after_search
期间说道滚屏，会问做滚屏期间需要注意什么
注意点：
1、滚屏是生成数据快照，在滚屏期间数据发生变化，迁移的数据是不会变得，这时要注意这部分数据的处理，比如可以发送一些消息出去，然后数据迁移完，进行消息的消费；
2、滚屏要注意续期；
3、滚屏结束要注意关闭，因为滚屏很消耗性能；

2、es的查询过程：
大概可分为两大阶段，第一阶段是query部分，这部分其实查询到的是一些满足条件的文档id，这部分查询速度其实挺快，也没有优化的必要，
第二阶段是fech阶段，这个解决是真正按照文档的id去各个分片上拉取数据；
这个解决比较繁重，也是优化的重点，比如在在聚合的时候关闭元数据，比如在查询不需要排序的时候关闭排序功能；？


3、es的相关度设置（权重），实际更改的是什么（实际更改的Lucene的评分）；

4、es索引的文档中有个version，是做什么的（或者直接问es是怎么怎么保证并发的）；
version是防止并发冲突，丢失更新而实现的乐观锁；当有需要更新文档的时候，会比对es中的version和你提供的version,只有一样的情况下才能更新；
也可以用外部version控制并发，和自带的version相比，只要提供的version比es的version大就可以更新

version是保证并发的，可以使用es自带的version，也可以使用外部自定义的version，自带的version必须要与es中的相等才可以更新；外部version需比es中的_version大才能更改；

5、es官方宣称是去中心化（可以理解为无中心化），但其实集群内部是有master的，这个master的选举机制是否有了解；
（这个说没了解过就行，免得都答了，别人怀疑我漏题，然后他们再问）
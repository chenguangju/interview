1、在项目中用过锁码？
用过ReentrantLock

2、他和sychronized有什么区别
1锁的实现）sychronized是java内置关键字，lock是jdk代码实现的
2锁的性能）sychronized在竞争不激烈的时候比lock的性能好，竞争激烈lock性能好
3用法）sychronized可以修饰代码块和方法，不需要显示释放锁；lock只能用在方法块，需要手动释放。
4公平性）sychronized非公平，ReentrantLock 则即可以选公平锁也可以选非公平锁

3、sychronized实现原理
偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能
轻量级锁只要有多个线程访问同步代码，就会进入偏向模式，并进行自旋等待锁
重量级锁sychronized实现和管程monitor相关。每个对象头都会关联一个monitor对象。monitor是实现锁的关键
当修饰代码块时是通过两个monitor指令完成monitorenter指令和monitorexit，遇见monitorenter就关联monitor
当修饰方法时通过ACC_SYNCHRONIZED标识锁过程，遇到ACC_SYNCHRONIZED就关联monitor。


4、sychronized锁升级过程
由偏向锁->轻量级锁->重量级锁
当线程第一次访问sychronized修饰的同步代码时，会把当前线程id设置为自己，这时是偏向锁
一旦有其他线程竞争锁时，就会升级为轻量级锁，其他线程会通过自旋去获取锁,(自旋锁，并不是sychronized的锁，更像是一个自旋操作)
当一段时间自旋后还没获取到锁10次、或者同时自旋的线程过多（自旋线程的数量超过了cpu的二分之一），就会升级为重量级锁->去关联monitor对象

5、产生死锁的条件
1）互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用
2）不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
3）占用且等待，线程已经获取了共享资源x,在等待资源Y时，不释放x
4）循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。

6、如何避免死锁
打破上面的条件即可，由于我们用锁就是用互斥主要有三种
1）不可抢占,占有部分资源的线程去申请另外资源时，如果申请不到，主动放弃已有资源。让其他线程可以获取到
2）占用且等待，一次申请多个资源，这样就不存在等待了
3）循环等待，所有的线程都按同一顺序申请资源

7、volatile怎么用
用来修饰共享变量，

8、volatile有什么特性
保证内存可见性。禁止指令重排序；

9、什么是指令重排序
CPU为了保证执行效率，在保证结果正确的情况下。对代码生成的指令进行重排序

10、volatile怎么保证可见性和指令重排序/原理
可见性：原理是每次修改volatile关键字修饰的变量时，都会把新值更新会主内存，并通知其他线程这个副本是无限状态。其他线程用时发现无效，直接读取主内存
禁止指令重排序；实现原理是内存屏障指令。
volatile会在变量写操作的前后加入两个内存屏障，来保证前面的写指令和后面的读指令是有序的。
volatile在变量的读操作后面插入两个指令，禁止后面的读指令和写指令重排序。

11、volatile可不可以用作锁
不可以，volatile并不保证原子性

12、悲观锁和乐观锁
悲观锁：总是假设要访问的数据被修改。所以每次用都会加锁-》比如sychronized
乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是更新的时候会比较一下有没有人更新-》CAS

13、什么是AQS
是一个用于构建锁和同步容器的同步器，比如ReentrantLock锁就是由AQS实现的
简称AQS队列同步器，分为独占模式和共享模式
独占模式即当锁被某个线程成功获取时，其他线程无法获取到该锁。互斥锁
共享模式即当锁被某个线程成功获取时，其他线程仍然可能获取到该锁。共享锁
两种模式对应一组api供子类实现。只能实现其一组
内部数据结构是一个双向链表队列+state+当前线程（exclusiveOwnerThread）
链表内的数据为Node 持有前后节点索引，哪个线程需要获取同步状态
链表内的首节点为不绑定Thread的空节点

